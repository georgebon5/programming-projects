ΠΕΡΙΓΡΑΦΗ
Αρχικά περνάω έξι ορίσματα από τη γραμμή εντολών μέσω argc και argv. Αν για κάποιον λόγο δεν περαστούν ή δεν δώθει σωστό πλήθος ορισμάτων τότε εκτυπώνω ανάλογο μήνυμα και τερματίζω το πρόγραμμα μου, επιστρέφοντας την τιμή 1. Στη συνέχεια, ελέγχω αν το πρώτο όρισμα είναι "enc" ή "dec". Αν δεν είναι, εκτυπώνω ανάλογο μήνυμα και τερματίζω το πρόγραμμα μου, επιστρέφοντας την τιμή 1.

Έπειτα, μετατρέπω όλα τα ορίσματά μου εκτός του πρώτου σε long long ακέραιους μέσω της συνάρτησης atoll. Αφού κάνω τη μετατροπή, ελέγχω αν οι αριθμοί είναι θετικοί. Αν δεν είναι, τότε το πρόγραμμα εκτυπώνει ανάλογο μήνυμα και τερματίζει με τιμή 1.

Μετά ελέγχω αν οι αριθμοί prime1 και prime2 είναι πρώτοι και διαφορετικοί. Αν δεν είναι, τότε εκτυπώνω το αντίστοιχο μήνυμα και τερματίζω το πρόγραμμα με τιμή 1. Υπολογίζω το N, που προκύπτει από το γινόμενο των prime1 και prime2, ώστε να χρησιμοποιήσω τη συνάρτηση του Euler, δηλαδή την phi(N) (η συνάρτηση του Euler μετράει το πλήθος των αριθμών από 1 μέχρι N-1 που είναι πρώτοι με το N), και ελέγχω αν το e είναι πρώτος με το φ(N). Αλλιώς, τερματίζω με αντίστοιχο μήνυμα και τιμή 1.

Ελέγχω αν το e * d mod φ(N) == 1, δηλαδή αν οι ακέραιοι e και d είναι αντίστροφοι. Αν δεν είναι, τερματίζω.

Μετά από τις παραπάνω διαδικασίες, διαβάζω το μήνυμα από την είσοδο και ελέγχω αν το μήνυμα είναι έγκυρο, δηλαδή αν msg >= N ή msg < 0. Τέλος, θα κάνω κρυπτογράφηση ή αποκρυπτογράφηση ανάλογα με την τιμή του πρώτου ορίσματος, δηλαδή αν είναι "enc" ή "dec".

Απλά επειδή δεν μπορώ να χρησιμοποιήσω την έτοιμη μαθηματική συνάρτηση pow για μεγάλους αριθμούς, θα φτιάξω δική μου συνάρτηση ώστε να υλοποιήσω αυτή την πράξη (base^exp mod mod). Οπότε το πρόγραμμά μου τερματίζει με το κρυπτογραφημένο ή αποκρυπτογραφημένο μήνυμα και τιμή 0.

*COMPILE
Στον κώδικά μου πραγματοποιείται μεταγλώττιση με την εντολή:
gcc -O3 -Wall -Wextra -Werror -pedantic -o rsa rsa.c

*RUN
Αφού γίνει η μεταγλώττιση, ο κώδικάς μου εκτελείται με την εντολή:
./rsa και τα αντίστοιχα ορίσματα.