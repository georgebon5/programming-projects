-ΒΙΒΛΙΟΘΗΚΕΣ-  
  stdio.h: Με τη χρήση αυτής της βιβλιοθήκης μπορώ να χρησιμοποιήσω τις συναρτήσεις printf, fprintf, fopen, fclose, fscanf και perror.

  stdlib.h: Με τη χρήση αυτής της βιβλιοθήκης μπορώ να χρησιμοποιήσω τις συναρτήσεις malloc, realloc, atoi και free.

  string.h: Με τη χρήση αυτής της βιβλιοθήκης μπορώ να χρησιμοποιήσω τη συνάρτηση strcmp.

-ΜΕΤΑΓΛΩΤΤΙΣΗ-  
  ``` gcc -Os -Wall -Wextra -Werror -pedantic -o future future.c ```

-MAIN-  
    Αρχικά εξετάζω το πλήθος των ορισμάτων καθώς αν δοθούν λιγότερα από 2 ορίσματα ή περισσότερα από 4, τότε το πρόγραμμα μου τερματίζει με αντίστοιχο μήνυμα και με κωδικό εξόδου 1.


  ```
    if (argc < 2 || argc > 4) {
      printf("Usage: ./future <filename> [--window N (default: 50)]\n");
        return 1;
  }
```

          
          
  Στη συνέχεια αρχικοποιώ τη σταθερή μεταβλητή filename, όπου θα αποθηκευτεί το δεύτερο όρισμα που έχει δώσει ο χρήστης στο terminal:   ``` const char *filename = argv[1]; ```  
  Επίσης, αρχικοποιώ το παράθυρο με την προεπιλεγμένη τιμή που είχα ορίσει αρχικά: ``` #define DEFAULT_WINDOW 50 ```  
  Ελέγχω το πλήθος των ορισμάτων. Αν είναι ίσο με 4, τότε μέσω της συνάρτησης strcmp εξετάζω αν ο χρήστης έχει πληκτρολογήσει σωστά. Αλλιώς, εκτυπώνεται κατάλληλο μήνυμα και το πρόγραμμα τερματίζει με κωδικό εξόδου 1.



  ```
     if (argc == 4) {
           if (strcmp(argv[2], "--window") != 0) {      
              fprintf(stderr, "Usage: ./future <filename> [--window N (default:    50)]\n");
            return 1;
        }
```


  Μετά από την παραπάνω διαδικασία, μετατρέπω το όρισμα που είναι τύπου char σε int μέσω της συνάρτησης atoi και την τιμή αυτή την περνάω στη μεταβλητή window. Αυτό σημαίνει ότι ο χρήστης έδωσε δική του τιμή παραθύρου. Στη συνέχεια ελέγχω αν η τιμή του παραθύρου είναι μικρότερη από 1. Τότε το πρόγραμμα μου εκτυπώνει κατάλληλο μήνυμα και τερματίζει με κωδικό εξόδου 1.  

 

  ``` 
        window = atoi(argv[3]); 
        if (window < 1) {  
            fprintf(stderr, "Window too small!\n");
            return 1;
        } 
  ```
Έπειτα ανοίγω το αρχείο με τη συνάρτηση fopen σε λειτουργία ανάγνωσης του περιεχομένου του. Αν το αρχείο δεν ανοίξει, εκτυπώνεται ανάλογο μήνυμα και τερματίζει με κωδικό εξόδου 1.



  ```
    FILE *file = fopen(filename, "r");
    if (!file) { 
        fprintf(stderr, "Error opening file\n");
        return 1;
    }
```

 
  Αρχικοποιώ τον δείκτη data και το μέγεθος του πίνακα ώστε να κάνω δυναμική δέσμευση 10 θέσεων με τη malloc. Επίσης, αρχικοποιώ και τη μεταβλητή size ώστε να την χρησιμοποιήσω αργότερα για να κάνω προσθήκη των στοιχείων στον πίνακα. 



  ```
    double *data = NULL;    
    int capacity = 10;
    int size = 0;
    data = malloc(capacity * sizeof(double));
```
  Αφού έκανα δυναμική δέσμευση του πίνακα, πρέπει να εξετάσω το ενδεχόμενο να μην έχει γίνει η δέσμευση της μνήμης.



  ```
  if (!data) { 
        fprintf(stderr, "Memory allocation failed\n");
        fclose(file);
        return 1;
    }
```
  Οπότε τώρα μένει να κάνω προσθήκη των στοιχείων του αρχείου μέσα στον πίνακα που έχω αρχικοποιήσει. Τη διαδικασία αυτή θα την υλοποιήσω μέσω μιας while. Κάθε φορά που διαβάζεται κάποιο στοιχείο, θα αποθηκεύεται στη μεταβλητή value. Έπειτα θα χρειαστώ τον μετρητή size που αρχικοποίησα πιο πάνω. Αν ο μετρητής είναι ίσος με το μέγεθος του πίνακα, τότε να διπλασιάζει το μέγεθος του πίνακα με τη συνάρτηση realloc. Αλλιώς, να περνάει την τιμή του στοιχείου στον πίνακα data και να αυξάνει κατά 1 τον μετρητή size. Η διαδικασία αυτή θα επαναλαμβάνεται μέχρι να διαβαστούν όλα τα στοιχεία του πίνακα. Μετά από τα παραπάνω, κλείνει το αρχείο.



  ```
    double value;
    while (fscanf(file, "%lf", &value) == 1) {     
        if (size == capacity) {
            capacity *= 2;      
            data = realloc(data, capacity * sizeof(double));   
            if (!data) {
                perror("Memory allocation failed");    
                fclose(file);      
                return 1;       
            }
        }
        data[size] = value; 
        ++size;     
    }
  fclose(file);
```


  Αφού περάστηκαν τα αρχεία, κάνω σύγκριση του μετρητή size με το παράθυρο. Δηλαδή, αν το παράθυρο είναι μεγαλύτερο του size, τότε κάνω αποδέσμευση μνήμης, εκτυπώνω αντίστοιχο μήνυμα και τερματίζω το πρόγραμμα με κωδικό εξόδου 1.



  ```
  if (window > size) {   
        fprintf(stderr, "Window too large!\n");
        free(data);
        return 1;
    }
```
   Τέλος, μέσω μιας for υπολογίζω τον μέσο όρο του παραθύρου, τον εκτυπώνω με δύο δεκαδικά ψηφία, κάνω αποδέσμευση μνήμης και τερματίζω το πρόγραμμα με κωδικό εξόδου 0.



  ```
    double sum = 0;
    for (int i = size - window; i < size; i++) {
         sum += data[i];
    }
    
    double avg = sum / window;
    printf("%.2f\n", avg);      

    free(data);      
    return 0;
```