![run-tests](../../workflows/run-tests/badge.svg)

## 2025 Project 1

Εκφώνηση: https://k08.chatzi.org/projects/project1/


### Προσωπικά στοιχεία

Στο αρχείο `AUTHORS` προσθέστε μια γραμμή με την παρακάτω μορφή:

```
sdi2400999,my-github-username,Όνομα Επώνυμο
```

Η σωστή μορφή του αρχείου ελέγχεται αυτόματα όταν κάνετε push στο github, σε
περίπτωση λάθους θα πάρετε μήνυμα στο email σας και θα πρέπει να το διορθώσετε για
να γίνει δεκτή η εργασία.

### Ασκήσεις που παραδίδονται

Συμπληρώστε εδώ τις ασκήσεις (και τυχόν bonus) που παραδίδετε. Αν κάποια άσκηση
βρίσκεται σε μη αναμενόμενα αρχεία αναφέρετε και τα αρχεία αυτά.

- ΑΣΚΗΣΗ 1
- ΑΣΚΗΣΗ 2
- ΑΣΚΗΣΗ 3
- ΑΣΚΗΣΗ 4
- ΑΣΚΗΣΗ 5
- ΑΣΚΗΣΗ 6

### Documentation
    Αρχικα εχω την συναρτηση state_info που επιστρεφει βασικες πληροφοριες του παιχνιδιου. Με την συναρτηση state_update ουσιαστικα ανανεωνεται η κατασταση του παιχνιδιου για καθε frame 
Εχω φτιαξει μια for που ουσιαστικα διασχιζει ολη την λιστα δηλαδη το φιδι ωστε να ανανεωνει το position του φιδιου(πρεπει ολοι οι κομβοι να ακολουθουν το κεφαλι). Στην συνεχεια εχω φτιαξει καποιες ωστε καθε φορα που παταω τα κουμπια right, left, up και down
τοτε να μετακινηται το φιδι. Αλλα αν το φιδι μετακινται προς τα πανω τοτε δεν μπορω να πατησω DOWN το ιδιο ισχυει και για το RIGHT LEFT. Επισης εχω τροποποιησει την μετακινηση του φιδιου ωστε να προκυπτει πολυπλοκοητα O(1)
αυτο το υλοποιησα παιρνωντας την διευθυνση του κεφαλιου, δεσμευω δυναμικα μνημη και χρησιμοποιω την  move_in_direction για να υπολογισω το καινουργιο κεφαλι στην συνεχεια αφαιρω την ουρα απο την λιστα με την συναρτηση list_remove_next και μετα προσθετω στο τελος την λιστας δηλαδη νεο κεφαλι με την list_insert_next 

# Τεχνική Αναφορά Υλοποίησης Παιχνιδιού Snake Game

## Εισαγωγή

Η παρούσα εργασία αφορά την υλοποίηση ενός διαδραστικού video game, παραλλαγή του κλασικού παιχνιδιού Snake. Στόχος του παιχνιδιού είναι το φίδι να μεγαλώσει όσο το δυνατόν περισσότερο, τρώγοντας μήλα και αποφεύγοντας αετούς. Η ανάπτυξη της εφαρμογής βασίστηκε στη χρήση της βιβλιοθήκης `raylib`, ενώ δόθηκε ιδιαίτερη έμφαση στον διαχωρισμό της λογικής του παιχνιδιού από το γραφικό περιβάλλον (information hiding και modular programming).

Η παρούσα αναφορά περιγράφει αναλυτικά τις τεχνικές προγραμματισμού και τις επιλογές σχεδίασης που χρησιμοποιήθηκαν, οργανωμένες σύμφωνα με τις απαιτήσεις της εκφώνησης.

---

## Άσκηση 1: Δημιουργία Αρχικής Κατάστασης (`state_create`, `state_info`, `state_objects`)

Η αρχικοποίηση της κατάστασης του παιχνιδιού υλοποιείται στη συνάρτηση `state_create`. Συγκεκριμένα:

- Ορίζεται η βασική δομή `State`, η οποία αποθηκεύει:
  - Το φίδι ως `List` από pointers σε διανύσματα τύπου `Vector2`.
  - Τα αντικείμενα (μήλα και αετούς) μέσω της δομής `ADTMap`, για αποδοτική αναζήτηση.
  - Πληροφορίες σχετικές με την κατάσταση του παιχνιδιού (παίζει/paused, σκορ, κατεύθυνση, frame counter).

- Το φίδι αρχικοποιείται με δύο τμήματα (κεφάλι και ουρά).
- Η συνάρτηση `add_random_objects` τοποθετεί τουλάχιστον 3 μήλα και 2 αετούς σε τυχαίες θέσεις, αποφεύγοντας σύγκρουση με το φίδι.

Η συνάρτηση `state_info` επιστρέφει τις βασικές πληροφορίες της κατάστασης, ενώ η `state_objects` επιστρέφει τα αντικείμενα που βρίσκονται εντός συγκεκριμένου παραλληλογράμμου, επιτρέποντας την απόδοση-κατευθυνόμενη σχεδίαση μόνο των ορατών στοιχείων.

---

## Άσκηση 2: Κίνηση Φιδιού και Ενημέρωση Κατάστασης (`state_update`)

Η συνάρτηση `state_update` υλοποιεί την ενημέρωση της κατάστασης του παιχνιδιού για κάθε frame. Βασικά χαρακτηριστικά:

- Η κατεύθυνση του φιδιού αλλάζει σύμφωνα με τα πατημένα πλήκτρα, με την απαγόρευση της άμεσης αναστροφής.
- Η κίνηση του φιδιού πραγματοποιείται κάθε `UPDATE_STATE_FRAMES` frames, μετακινώντας όλα τα τμήματα του σώματος προς τη θέση του επόμενου, ενώ το κεφάλι κινείται στην κατεύθυνση του `snake_direction`.
- Υποστηρίζεται παύση (`P`), συνέχιση και μεμονωμένη ενημέρωση (`N` για debugging).

Η σωστή λειτουργία επαληθεύεται με unit tests που ελέγχουν την ορθή μεταβολή της θέσης του φιδιού.

---

## Άσκηση 3: Συγκρούσεις, Σκορ και Αντικείμενα

Η συνάρτηση `state_update` επεκτείνεται με τις παρακάτω λειτουργίες:

### Σύγκρουση με μήλα
- Εάν το κεφάλι του φιδιού συγκρουστεί με μήλο:
  - Το σκορ αυξάνεται κατά 1.
  - Το σώμα του φιδιού μεγαλώνει με την προσθήκη νέου κεφαλιού.
  - Το μήλο αφαιρείται από το map των αντικειμένων.

### Σύγκρουση με αετούς και σώμα φιδιού
- Εάν το κεφάλι ή οποιοδήποτε τμήμα του φιδιού συγκρουστεί με αετό, ή αν το κεφάλι συγκρουστεί με το σώμα του φιδιού, το παιχνίδι τερματίζεται (game over).

### Δημιουργία νέων αντικειμένων
- Ελέγχεται αν υπάρχουν τουλάχιστον `MIN_APPLES_NUM` μήλα και `MIN_EAGLES_NUM` αετοί σε απόσταση `MAX_DIST` από το φίδι. Αν όχι, προστίθενται τα απαραίτητα αντικείμενα.

---

## Άσκηση 4: Βελτιστοποίηση Κίνησης σε Σταθερό Χρόνο (O(1))

Η κίνηση του φιδιού βελτιστοποιείται ώστε να γίνεται σε χρόνο O(1), αφαιρώντας το παλαιότερο τμήμα (ουρά) και προσθέτοντας νέο κεφάλι στην κατεύθυνση κίνησης. Με αυτόν τον τρόπο αποφεύγεται η ανάγκη μετακίνησης όλων των τμημάτων, βελτιώνοντας την αποδοτικότητα.

---

## Άσκηση 5: Εναλλακτική Υλοποίηση με `state_alt.c` (Χρήση Map)

Στην εναλλακτική υλοποίηση `state_alt.c`, αντί για χρήση Vector, τα αντικείμενα αποθηκεύονται σε `ADTMap`. Το `GridCoord` χρησιμοποιείται ως key για εύκολη αναζήτηση με βάση τις συντεταγμένες.

Οφέλη της προσέγγισης:
- Γρήγορη επιστροφή των ορατών αντικειμένων στο `state_objects`.
- Αποδοτική ενημέρωση μόνο των αντικειμένων σε κοντινή απόσταση από το φίδι.
- Ταχύτερη ανίχνευση συγκρούσεων.

---

## Άσκηση 6: Υλοποίηση Γραφικού Περιβάλλοντος (`interface.c`)

Το γραφικό περιβάλλον υλοποιείται στο `interface.c` με χρήση της `raylib`. Οι βασικές λειτουργίες είναι:

- Αρχικοποίηση παραθύρου και ήχου (`interface_init`).
- Σχεδίαση κάθε frame (`interface_draw_frame`) με:
  - Το φίδι.
  - Τα μήλα και τους αετούς.
  - Το σκορ και το FPS.
  - Μήνυμα `GAME OVER` όταν το παιχνίδι σταματά.
- Διακοπή μουσικής και αναπαραγωγή ήχου game over όταν συμβαίνει σύγκρουση.
- Επανεκκίνηση του παιχνιδιού με το πλήκτρο `Enter`.

---

## Συμπεράσματα

Η υλοποίηση πληροί όλες τις απαιτήσεις της εκφώνησης, δίνοντας έμφαση σε:
- Modular σχεδίαση.
- Information hiding.
- Αποδοτική διαχείριση αντικειμένων με χρήση Map.
- Βελτιστοποιημένη κίνηση του φιδιού.
- Γραφικό interface με πλήρη λειτουργικότητα.

Η δομή του προγράμματος επιτρέπει εύκολη συντήρηση και επέκταση, ενώ η χρήση της `raylib` διασφαλίζει ομαλή απόδοση και καλή εμπειρία χρήστη.

---

**Τέλος αναφοράς.**

